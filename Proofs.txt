
Divisible-by-6 Extraction Algorithm and Proof (for multisets of {1,2,3,4,5})
----------------------------------------------------------------------------

Problem setting
---------------
Input: A multiset A of integers, each in {1,2,3,4,5}. Let S = sum(A).
Goal: Constructively extract subsets whose sums are divisible by 6 until at most
      5 elements remain; prove the resulting decomposition
          S = 6a + R     with a = floor(S/6), R in {0,1,2,3,4,5},
      and formalize how the algorithm implies S = 6(b+c) + R = 6a + R for some b,c >= 0.


Key lemma (6-element zero-sum lemma)
------------------------------------
Lemma. Every 6-element multiset C drawn from {1,2,3,4,5} contains a nonempty subset
whose sum is 0 (mod 6).

Proof (standard prefix sums / pigeonhole). Order the six elements arbitrarily as c1,...,c6.
Consider the six prefix sums Pk = (c1 + ... + ck) mod 6 for k=1..6. If any Pk = 0, then
{c1,...,ck} is a nonempty subset summing to 0 (mod 6). Otherwise, all Pk lie in {1,2,3,4,5};
by the pigeonhole principle, two of them coincide: Pi = Pj with i<j. Then the sum
(c_{i+1} + ... + c_j) has residue 0 (mod 6) and is a nonempty subset. ∎


Algorithm (operational form)
----------------------------
Case 1: If |A| ≤ 5, stop immediately. Set L_work := A and L_out := ∅.

Case 2: If |A| > 5:
  Working lists:
    L_work ← copy(A)      // mutable working multiset
    L_out  ← []           // collects all extracted divisible-by-6 elements

  While |L_work| > 5:
    1) Partition L_work (in any fixed order) into consecutive blocks of size 6 and
       one remainder block of size r ∈ {0,1,2,3,4,5}.
    2) For each 6-block C:
          - By the lemma, choose a nonempty subset Z ⊆ C with sum(Z) ≡ 0 (mod 6).
          - Move all elements of Z from L_work into L_out.
       (Do NOT remove the other elements from C; they remain in L_work for future passes.)

  Let R_list := L_work at termination (so |R_list| ≤ 5).
  Output the collection of extracted subsets in L_out (call them {B_i}) and the leftover R_list.


Invariants and termination
--------------------------
I1 (divisible extraction). Every element moved to L_out belongs to some subset Z with
    sum(Z) ≡ 0 (mod 6). Hence sum(L_out) ≡ 0 (mod 6).

I2 (congruence of leftover). No element is destroyed; all non-extracted elements remain
    in L_work. Therefore for all times,  S = sum(L_out) + sum(L_work).
    In particular, at termination:  S = sum(L_out) + sum(R_list).

I3 (strict progress). Each 6-block yields a nonempty Z which is removed; consequently,
    |L_work| strictly decreases across iterations. The loop halts once |L_work| ≤ 5.

At termination, |R_list| ≤ 5 and each entry ≤ 5, so sum(R_list) ∈ {0,1,2,3,4,5,6,...,25}.
Moreover sum(R_list) ≡ S (mod 6) by I2 and I1.


Decomposition and the roles of a, b, c, and R
---------------------------------------------
Define:
  • b ≥ 0 by sum(L_out) = 6b (this is well-defined by I1).
  • Let the leftover sum be written as
        sum(R_list) = 6c + R,   with c ≥ 0 and R ∈ {0,1,2,3,4,5},
    where R is the least nonnegative residue of S modulo 6.

Then
  S = sum(L_out) + sum(R_list) = 6b + (6c + R) = 6(b + c) + R.

Setting
  a := floor(S/6),
we necessarily have a = b + c (since 0 ≤ R ≤ 5), hence
  S = 6a + R.


Correctness summary
-------------------
By the lemma, each 6-block always contributes a divisible-by-6 subset, ensuring progress.
By invariants I1–I3, the loop terminates with ≤5 leftover elements and
  S = sum(L_out) + sum(R_list),  sum(L_out) ≡ 0 (mod 6),  sum(R_list) ≡ S (mod 6).
Therefore we can write sum(L_out) = 6b and sum(R_list) = 6c + R with R = S mod 6,
giving S = 6(b+c) + R = 6a + R with a = floor(S/6).
This matches the desired structural decomposition and explains the roles of b and c.
